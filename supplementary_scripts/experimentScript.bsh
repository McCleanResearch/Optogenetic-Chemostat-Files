/*
SUMMARY:
This script is intended to control a microscope and to control a microcontroller running the chemostatController.ino file. It tells the microcontroller
what ratio of time peristaltic pumps should be on, and when the sampling pump should be off. It controls the microscope to acquire images of the yeast. It then
uses FIJI's software to analyze those images.

INPUT:
1) This program assumes that the positions to images are listed in micromanager's "stage position list."

OUTPUT:
1) Many images
2) A summary.csv file summarizing the experiment
3) A microcontrollerRecords.csv file, containing messages received from the microcontroller
4) A translations.csv file. IT is useful to know the translations that were applied images in order to align them.
REQUIRES:
1) FIJI (or imageJ)
2) Micromanager
3) The users to review the values of the initially declared variables below. The values of certain parameters are hard-coded into the script for each time that this is run.
    
    
    Written by Cameron Stewart
						Research intern at UW-Madison
               cameronstewart92@gmail.com
    Last revised on February 29, 2016
 */



import mmcorej.CharVector; 
import org.micromanager.api.AcquisitionOptions;
import org.micromanager.api.PositionList;
import org.micromanager.api.MultiStagePosition;
import org.micromanager.api.StagePosition;


import java.text.SimpleDateFormat;
import java.util.Date;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.lang.System;
import java.io.BufferedReader;
import java.io.FileReader;
import Java.nio.file.Path;
import Java.nio.file.Paths;

import org.apache.commons.math.stat.StatUtils;
import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;

import ij.IJ;
import ij.ImagePlus;
import ij.io.Opener;
import ij.measure.Measurements;
import ij.measure.ResultsTable;
import ij.plugin.filter.BackgroundSubtracter;
import ij.plugin.filter.ParticleAnalyzer;
import ij.process.ImageProcessor;
import ij.ImagePlus;
import ij.io.FileSaver;
import ij.WindowManager;  
import ij.text.TextWindow; 
import ij.plugin.Duplicator;
import ij.text.TextPanel;
import ij.plugin.frame.RoiManager;
import ij.plugin.ImageCalculator;


public String[][] getValuesFromCSV(String filename, int columns){
	// This code assumes that the value of the 2nd column of the 2nd row is the number of remaining rows
	//filename is the name of the file that will be opened in the current directory. Ex: bioreactorParameters.csv
	//columns is the number of columns that will be saved as values to the values array. So if there are three
	//columns of data, enter 3 and they will be stored as columns 0-2. 
	File file = new File("");
	currentDirectory = file.getAbsolutePath();
	print("Current working directory : "+currentDirectory);
	
	String DELIMITER = ",";
	BufferedReader fileReader = null;
	String[][] values;
	try {
		String line = "";
		//Create the file reader
		fileReader = new BufferedReader(new FileReader(currentDirectory+"\\"+filename));
		//Ignore header
		line = fileReader.readLine();
		//Get the number of parameters from the second line
		line = fileReader.readLine();
		String[] tokens = line.split(DELIMITER);
		int numValues=Integer.parseInt(tokens[1]);
		values=new String[numValues][columns];
		for(int i=0; i<numValues; i++) {
			line = fileReader.readLine();
			String[] tokens = line.split(DELIMITER);
			for(int j=0; j<columns; j++){
				values[i][j]=tokens[j];
				}
			}
		}
	
	catch (Exception e) {
		System.out.println("Error in CsvFileReader when reading: "+filename);
		e.printStackTrace();
		} finally {
		 try {
		fileReader.close();
		} catch (IOException e) {
		System.out.println("Error while closing fileReader !!!");
		e.printStackTrace();
		}
	}
	return values;
}

public alignImages(String title1, String title2){
	imp = IJ.openImage(title1);
	imp.show();
	imp2 = IJ.openImage(title2);
	imp2.show();
	IJ.run(imp, "Images to Stack", "name=Stack title=[] use");
	imp = IJ.getImage();
	//IJ.setTool("rectangle");
	IJ.run(imp, "Align slices in stack...", "method=5 windowsizex=2487 windowsizey=2067 x0=36 y0=48 swindow=0 subpixel=false itpmethod=0 ref.slice=1 show=true");
	TextWindow tw = (TextWindow)WindowManager.getFrame("Results"); 
	TextPanel tp=tw.getTextPanel();
	ResultsTable st = tp.getResultsTable(); 
	
	 int n=st.getCounter(); //Assumes that summaries (Mean, SD, Max, Min...) have NOT been added after the last result
	 int dX=(int) st.getValue("dX",0);
	 int dY=(int) st.getValue("dY",0);
	 IJ.run("Close All", "");//close all windows
	 imp2 = IJ.openImage(title2);
	imp2.show();
	//IJ.run(imp, "Translate...", "x=-37.5 y=-45 interpolation=None")
	String offset="x="+dX+" y="+dY+" interpolation=None";
	//The stack is ordered alphabetically.
	if(title1.compareTo(title2)<0){
		IJ.run(imp2, "Translate...",offset);
		IJ.saveAs(imp2,imageType[0], title2);
		FileWriter writer = new FileWriter(saveDir+translationFile+startTime+".csv",true); 
		writer.write(title2+", "+dX+", "+dY+lineSeparator);
		writer.close();
}else if(title1.compareTo(title2)>0){
		IJ.run(imp1, "Translate...",offset);
		IJ.saveAs(imp1,imageType[0], title1);
		FileWriter writer = new FileWriter(saveDir+translationFile+startTime+".csv",true); 
		writer.write(title1+", "+dX+", "+dY+lineSeparator);
		writer.close();
	}else
		print("WARNING. Titles cannot be identical");
}

public int processAndThreshold(String title, String saveAs){//CJS

	//This workflow is based on http://fiji.sc/Segmentation
	IJ.run("Close All", "");
	ImagePlus imp=IJ.openImage(title);
	//This code can be easily replaced by code recorded while manually
	//manipulating an image Plugins > Macros> Record... > Record BeanShell
	//This script assumes that rm will be updated (probably by using the Particle Analyzer)
	Thread.sleep(200);//give time for image to open
	imp.show();
	IJ.run(imp, "Smooth", ""); //Smooth and then find edges tends to reduce the noise more than the signal
	IJ.run(imp, "Subtract Background...", "rolling=30");
	IJ.run(imp, "Find Edges", "");
	//IJ.run(imp, "Subtract Background...", "rolling=5"); //too slow. not very helpful
//	IJ.setAutoThreshold(imp, "IsoData dark"); //THresholds tends to be too low. Includes too much junk
	IJ.setAutoThreshold(imp, "Moments dark");
	Prefs.blackBackground = true;
	IJ.run(imp, "Convert to Mask", "");

//remove outliers 20 pixels
//close twice
	IJ.run(imp, "Remove Outliers...", "radius=10 threshold=50 which=Bright");
	IJ.run(imp, "Options...", "iterations=5 count=1 black do=Nothing");
	IJ.run(imp, "Dilate", "");
	IJ.run(imp, "Options...", "iterations=2 count=1 black do=Nothing");
	IJ.run(imp, "Close-", "");
	IJ.run(imp, "Fill Holes", "");
	IJ.run(imp, "Options...", "iterations=5 count=1 black do=Nothing");
	IJ.run(imp, "Erode", "");
	IJ.run(imp, "Remove Outliers...", "radius=20 threshold=50 which=Bright");

	rm = RoiManager.getInstance();
	if (rm==null) rm = new RoiManager();
	if(rm.getCount()!=0){//Clear ROI manager
		rm.runCommand("Deselect");
		rm.runCommand("Delete");
	}
	rm.runCommand("Show All with labels");
	rm.runCommand("Show All");
	//This is configured for the 40X objective
	IJ.run(imp, "Analyze Particles...", analyzeParticlesParameters);//changed from 1215
		//"Analyze Particles..." automatically updates rm
	Thread.sleep(100);
	IJ.saveAs(imp,imageType[0], saveAs);
	Thread.sleep(500);//time for images to save
		//If nothing was mesured, it is non-diagnostic. Update expHistory accordingly
		return rm.getCount();
}

public void analyzeROIs(String title){//This fills the results table
	rm = RoiManager.getInstance();
	imp=IJ.openImage(title);
	imp.show();//Showing the image is important because it selects the image. Some of these commands run on the selected image
	IJ.run(imp,"From ROI Manager", ""); //get ROIs from rm and set as Overlay on imp2
	IJ.run("Set Measurements...", "area mean standard min median redirect=None decimal=3");
	rm.runCommand("Measure"); //get new results
	IJ.saveAs(imp, imageType[0],title);
}
public void backgroundArithmetic(String bg, String image, String saveAs, String method){
	imp1=IJ.openImage(image);
	imp1.show();
	Thread.sleep(50);
	imp2=IJ.openImage(bg); //Background image created by generateBG()
	imp2.show();
	Thread.sleep(50);//Give time for images to open
	ImageCalculator ic = new ImageCalculator();
	ImagePlus imp3 = ic.run(method+" create", imp1, imp2);
	Thread.sleep(50);
	imp3.show();
	IJ.saveAs(imageType[0], saveAs);
	Thread.sleep(50);//give time for image to save
}	
//This generates the background by taking several images and using the median pixel from each.
public void generateBG(){
	print("The current time is "+sdf.format(new Date()));
	print("The microscope will now acquire "+bgSamples+" at each of the "+pl.getNumberOfPositions()+" positions specified.");
	print("The median pixel of the images at each position will be used to create a background image for each position.");
	print("The background image will then be subtracted from later acquired images so that the difference between the image and the background is emphasized.");
	for(int q=0;q<bgSamples;q++){
		mmc.setConfig(configGroup,darkPreset);
		while(System.currentTimeMillis()<(lastBG+((1-sampleRatioOn)*controllerInterval))){
			// While not enough time has passed to ensure that the media has moved since the last set of images were taken
			Thread.sleep(1000);
		}
				//Take images
			for (int l=0; l < pl.getNumberOfPositions(); l++) {
				MultiStagePosition.goToPosition(pl.getPosition(l), mmc);
				for (int i=0;i<configPresets.length;i++){
					mmc.setConfig(configGroup,configPresets[i]);
					mmc.waitForSystem();
					Thread.sleep(20); //let vibrations dissipate
					gui.snapSingleImage();
					Thread.sleep(20);//Make sure things are synchronized
					mmc.setConfig(configGroup,darkPreset);
					//Save Image1 as it is. This also delays when the next images is taken, 
					//which prevents micromanager and imageJ from acting out of sync	
					Thread.sleep(300); //500 millisecond delay. ImageJ cannot get the image (and therefore cannot save it) until the image loaded
					IJ.saveAs(imageType[0], saveDir+"BG_"+configPresets[i]+"_Position_"+l+"_Sample_"+q+imageType[1]);
					Thread.sleep(100);//Give time for images to save
				}
		}//end for loop
		//Turn off pinch valve (open). Turn on room lights
	}
	//Make image from the median pixel of each
	for (int l=0; l < pl.getNumberOfPositions(); l++) {
		for(int i=0;i<configPresets.length;i++){
		IJ.run("Close All", "");//close all windows
		for(int q=0;q<bgSamples;q++){
			imp=IJ.openImage(saveDir+"BG_"+configPresets[i]+"_Position_"+l+"_Sample_"+q+imageType[1]);
			Thread.sleep(50); //50 millisecond delay. ImageJ cannot get the image until the image loaded
			imp.show();
			Thread.sleep(50); //50 millisecond delay. ImageJ cannot get the image until the image loaded
			}
		IJ.run("Images to Stack", "name=Stack title=[] use");
	   Thread.sleep((20*bgSamples)+200); //give time to make stack
		IJ.run("Z Project...", "start=[] stop=[] projection=Median");
		Thread.sleep((20*bgSamples)+200); //give time to make new image
		IJ.saveAs(imageType[0], saveDir+"BG_"+configPresets[i]+"_Position_"+l+imageType[1]);
		Thread.sleep(300); //give time for image to save
		}
	}
}

public void preparePositions(){
	print("There are this many positions: "+pl.getNumberOfPositions());
	if(pl.getNumberOfPositions()==0){
		gui.markCurrentPosition();
		print("The stage will not move.");
	}
	if(pl.getNumberOfPositions()==1){
		print("The stage will stay at the only position in the stage position list.");
	}
	if(pl.getNumberOfPositions()>2){
		print("The stage will move to the positions in the stage position list.");
	}
	if(pl.getNumberOfPositions()==2){
		print("The stage will take images "+intervals+" images along the line formed by the two positions in the stage position list.");
	double x0=pl.getPosition(0).getX();
	double y0=pl.getPosition(0).getY();
	double z0=pl.getPosition(0).getZ();
	
	double x1=pl.getPosition(1).getX();
	double y1=pl.getPosition(1).getY();
	double z1=pl.getPosition(1).getZ();
	
	double deltaX=(x1-x0)/intervals;
	double deltaY=(y1-y0)/intervals;
	double deltaZ=(z1-z0)/intervals;
	pl.clearAllPositions();
	for (int i=0;i<intervals;i++){
		MultiStagePosition msp = new MultiStagePosition(xyStage,x0+(i*deltaX) , y0+(deltaY*i), zStage, z0+(deltaZ*i));
		pl.addPosition(msp);
	}
	}
}
public double saveResults(String title, String dataFile){
	IJ.saveAs("Results", title);
	TextWindow tw = (TextWindow)WindowManager.getFrame("Results"); 
	 TextPanel tp=tw.getTextPanel();
	 ResultsTable st = tp.getResultsTable(); 
	
	 int n=st.getCounter(); //Assumes that summaries (Mean, SD, Max, Min...) have NOT been added after the last result
	 double[] meanArr=st.getColumnAsDoubles(st.getColumnIndex("Mean"));
	 double[] SDArr=st.getColumnAsDoubles(st.getColumnIndex("StdDev"));
	 double[] medianArr=st.getColumnAsDoubles(st.getColumnIndex("Median"));
	 double[] maxArr=st.getColumnAsDoubles(st.getColumnIndex("Max"));
	 double[] areaArr=st.getColumnAsDoubles(st.getColumnIndex("Area"));
	 double medianMean=StatUtils.percentile(meanArr, 50);
	 double medianSD=StatUtils.percentile(SDArr, 50);
	 double medianMedian=StatUtils.percentile(medianArr, 50);
 	 double medianMax=StatUtils.percentile(maxArr, 50);
	 double medianArea=StatUtils.percentile(areaArr, 50);
	 double meanMax=StatUtils.mean(maxArr);
	 double meanArea=StatUtils.mean(areaArr);
	 double meanMean=StatUtils.mean(meanArr);
	 double ninetyPMean=StatUtils.percentile(meanArr, 90);
	 double ninetyPMedian=StatUtils.percentile(medianArr, 90);
	 double ninetyPMax=StatUtils.percentile(maxArr, 90);

		FileWriter writer = new FileWriter(dataFile,true); 
		writer.write(imageTime+", "+Double.toString(medianMean)+", "+Double.toString(meanMean)+", "+Double.toString(ninetyPMean)+", "+Double.toString(medianSD)+", "
		+Double.toString(medianMedian)+", "+Double.toString(ninetyPMedian)+", "+Double.toString(meanMax)+", "+Double.toString(medianMax)+", "+Double.toString(ninetyPMax)+", "
		+Double.toString(meanArea)+", "+Double.toString(medianArea)+", "+Integer.toString(n));
		writer.close();
		return meanMax;
}
public void sendImmediateMessage(float mediaRatioOn, int samplePumpPWM, int pinchValve, int roomLights){
	//i indicates the initiation of a message
	command = "i,"+mediaRatioOn+","+samplePumpPWM+","+pinchValve+","+roomLights; 
	mmc.setSerialPortCommand(arduinoPort, command, commandTerminator); 
	Thread.sleep(1000);
	String answer = mmc.getSerialPortAnswer(arduinoPort, commandTerminator); 
	if(answer.charAt(0)=='s'){//If the character indicating the start of a message is recieved (filter out junk messages)
		print(answer.substring(1,answer.length()-1)+"<- milliseconds since timecourse began, measured temperature of bioreactor");
		FileWriter writer = new FileWriter(saveDir+tempFile+startTime+".csv",true); 
		writer.write("Computer time in milliseconds since the start of the run,"+(System.currentTimeMillis()-startTimeMillis)+",Ardunio timecourse time then temperature in degrees C,"+answer.substring(1,answer.length()-1)+lineSeparator);
		writer.close();
	}
}
public void loadTimeCourse(){

	//mmc.setSerialPortCommand(port,"i,0,0,0,0",commandTerminator);
	for (int i=0;i<timeCourse.length;i++){
		print(timeCourse[i]);
		mmc.setSerialPortCommand(arduinoPort, "t,"+i+","+Arrays.toString(timeCourse[i]), commandTerminator);
		Thread.sleep(300);
	} 
}

public void acquireImages(){
		IJ.run("Clear Results", ""); //clear previous results
		IJ.run("Close All", "");//close all windows
		gui.snapSingleImage();//This first image is taken because the command is slow the first time that it is run. 
		//Subsequent calls load the image within 50milliseconds (on the old 32 bit computer it was made for :D )
		//It causes problems if imageJ commands are called immediatly afterwards
		Thread.sleep(500);
		//imageTime is when the image was taken, relative to the start of this script being run, in minutes
		imageTime=((System.currentTimeMillis()-startTimeMillis)/60000);
		
		//*******Take images for each position in the list, in each channel***************//
		
		PositionList pl = gui.getPositionList();
		for (int l=0; l < pl.getNumberOfPositions(); l++) {
			MultiStagePosition.goToPosition(pl.getPosition(l), mmc);
			mmc.waitForSystem();
			Thread.sleep(1000); //Give time for things to settle
			for (int i=0;i<configPresets.length;i++){//This portion needs to be fast to reduce discrepancy between images
				mmc.setConfig(configGroup,configPresets[i]);
				mmc.waitForSystem();
				gui.snapSingleImage();			
				Thread.sleep(50); //Give time for things to settle	
				if(needBgSamples)
					IJ.saveAs(imageType[0], saveDir+imageNumber+"_"+configPresets[i]+"_Position_"+l+imageType[1]);
				else
					IJ.saveAs(imageType[0], saveDir+imageNumber+"_"+configPresets[i]+"_Position_"+l+"_BG_Subtracted"+imageType[1]);
				}
				mmc.setConfig(configGroup,darkPreset);// Return to configurationpresets[0]. This is useful if other presets fluorescent light
			}
		Thread.sleep(100); //Give time to save images
		IJ.run("Close All", "");//close all windows
}
public double getData(){
	double intensity=-314;//A preposterous value to signify that it was not updated

		//**************************Process images************************************//
		
		//PREPARE IMAGES. Subtract background from each image (or other operation) and translate Images
			for (int l=0; l < pl.getNumberOfPositions(); l++) {
				for (int i=0;i<configPresets.length;i++){
					backgroundArithmetic(saveDir+"BG_"+configPresets[i]+"_Position_"+l+imageType[1],
												saveDir+imageNumber+"_"+configPresets[i]+"_Position_"+l+imageType[1],
												saveDir+imageNumber+"_"+configPresets[i]+"_Position_"+l+"_BG_Subtracted"+imageType[1],
												configPresetsBG[i]);
				}
			
			IJ.run("Close All", "");//close all windows
			IJ.run("Clear Results", ""); //clear previous results
			//WARNING: The stack is ordered alphabetically. Insert titles alphabetically ordered. title 1 should preced title2
			print("Align : "+saveDir+imageNumber+"_"+configPresets[roiPreset]+"_Position_"+l+"_BG_Subtracted"+imageType[1]+" and "+saveDir+imageNumber+"_"+configPresets[analyzePreset]+"_Position_"+l+"_BG_Subtracted"+imageType[1]);
			alignImages(saveDir+imageNumber+"_"+configPresets[roiPreset]+"_Position_"+l+"_BG_Subtracted"+imageType[1],saveDir+imageNumber+"_"+configPresets[analyzePreset]+"_Position_"+l+"_BG_Subtracted"+imageType[1]);
			IJ.run("Close All", "");//close all windows
			}
			
					//**************************Analyze images************************************//
					
			//ANALYZE IMAGES processAndThreshold fills the ROI manager after creating a binary using code that comes from ImageJ > PlugIns> Macros > Record > Beanshell script
			IJ.run("Clear Results", ""); //clear previous results
			for (int l=0; l < pl.getNumberOfPositions(); l++) {
			ROIsAtPosition=processAndThreshold(saveDir+imageNumber+"_"+configPresets[roiPreset]+"_Position_"+l+"_BG_Subtracted"+imageType[1],
											saveDir+imageNumber+"_"+configPresets[roiPreset]+"_Position_"+l+"_BG_Subtracted_Binary"+imageType[1]);
			IJ.run("Close All", "");//close all windows
			Thread.sleep(100);
			//If there are regions of interest, analyze the following image using the ROIs from the ROI manager. An overlay will be saved on it (which doesn't hange the image)
			if(ROIsAtPosition>0)
				analyzeROIs(saveDir+imageNumber+"_"+configPresets[analyzePreset]+"_Position_"+l+"_BG_Subtracted"+imageType[1]);
			ROIs=ROIs+ROIsAtPosition;
			}

		//**************************Save data************************************//
			
			if(ROIs>0){
				intensity=saveResults(saveDir+"Results"+imageNumber+".xls",saveDir+dataFile+startTime+".csv");
			IJ.run("Distribution...", "parameter=Median or=100 and=0-1000");
			IJ.saveAs("PNG", saveDir+"Median Distribution"+imageNumber+".png");
			IJ.run("Distribution...", "parameter=Max or=100 and=0-1000");
			IJ.saveAs("PNG", saveDir+"Max Distribution"+imageNumber+".png");
			IJ.run("Distribution...", "parameter=Mean or=100 and=0-1000");
			IJ.saveAs("PNG", saveDir+"Mean Distribution"+imageNumber+".png");
			IJ.run("Distribution...", "parameter=Area or=180 and=300-8550");
			IJ.saveAs("PNG", saveDir+"Area Distribution"+imageNumber+".png");
			}else{//If processAndThreshold returned no ROIs, there is nothing to do. Update dataFile accordingly
			FileWriter writer = new FileWriter(saveDir+dataFile+startTime+".csv",true); 
			writer.write(imageTime+", NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0");
			writer.close();
		}
		FileWriter writer = new FileWriter(saveDir+dataFile+startTime+".csv",true); 
		writer.write(", "+lightOnTime+", "+lightOffTime+", "+pumpOffDelay+", "+mediaOnTime+", "+mediaOffTime+lineSeparator);
		writer.close();
		return intensity;
}
public void prepareDataFile(){
	FileWriter writer = new FileWriter(saveDir+dataFile+startTime+".csv",true); 
	writer.write("The background was subtracted from images,"+needBgSamples+lineSeparator);
	writer.write("The median pixel of this many images was used to generate the background,"+bgSamples+lineSeparator);
	writer.write("Number of milliseconds that the experiment is set to last,"+durationMillis+lineSeparator);
	writer.write("Before each non-background image was acquired yeast settled for this many milliseconds,"+pumpOffDelay+lineSeparator);
	writer.write("Micromanager configuration group,"+configGroup+lineSeparator);
	writer.write("Preset used to acquire image to segment where the yeast are,"+configPresets[roiPreset]+lineSeparator);
	writer.write("Preset used to measure fluorescence intensity within previously acquired segmentations,"+configPresets[analyzePreset]+lineSeparator);
	writer.write("Preset that was used between images,"+darkPreset+lineSeparator);
	writer.write(lineSeparator+lineSeparator);
	writer.write("time (min), Median Mean Intensity, Mean Mean Instensity, 90th Percentile of Means, Median SD of Intensity, Median Median Intensity, 90th Percentile of Medians,"
		+"Mean Max, Median Max, 90th Percentile of Maxes, Mean Area, Median Area, Sample Size, Light On Time, Light Off Time, Pump On Delay, Pump Off Delay, MediaOnTime, MediaOffTime"+lineSeparator);
	writer.close();
}
public void reAnalyzeImages(int first,int last, String dataFile){
	FileWriter writer = new FileWriter(saveDir+dataFile+startTime+".csv",true); 
	writer.write("imageTime, medianMean, meanMean, ninetyPMean, medianSD, medianMedian, ninetyPMedian, meanMax, medianMax, ninetyPMax, meanArea, medianArea, n,\n");
	writer.close();
	
	for(int imageNumber=1;imageNumber<=nrImages;imageNumber++){
		//get data for each image
	}

		print("Done.");
		Thread.sleep(10000);
		System.exit(0);
}


//**************************************************************************************************************************
//****************INITIALIZING STEPS BELOW********************************************************************************************
//**************************************************************************************************************************
int idx=1; //The column of the values in the parameters array
String[][] parameters=getValuesFromCSV("bioreactorParameters.csv",2);
String[][] timeCourse=getValuesFromCSV("bioreactorTimecourse.csv",3);
String saveDir=parameters[0][idx]; //directory where output files will be saved.
boolean retroAnalysis=(parameters[1][idx]=="1");
int nrImages=Integer.parseInt(parameters[2][idx]);
String controllerPort = parameters[3][idx];
int controllerInterval=Integer.parseInt(parameters[4][idx]);
float mediaRatioOn=Float.parseFloat(parameters[5][idx]);
float sampleRatioOn=Float.parseFloat(parameters[6][idx]);
long durationMillis=Long.parseLong(parameters[7][idx]);
int bgSamples=Integer.parseInt(parameters[8][idx]);
int stageIntervals=Integer.parseInt(parameters[9][idx]);
long settlingTime=Long.parseLong(parameters[10][idx]);
String configGroup=parameters[11][idx];
String configPresetFind=parameters[12][idx];
String configPresetAnalyze=parameters[13][idx];
String configPresetDark=parameters[14][idx];
String imageTypeName=parameters[15][idx];
String imageTypeSuffix=parameters[16][idx];
String analyzeParticlesParameters=parameters[17][idx];
String lineSeparator=parameters[18][idx];
String commandTerminator=parameters[19][idx];
String dataFile=parameters[20][idx];
String translationFile=parameters[21][idx];
String temperatureFile=parameters[22][idx];
int controllerMessageDelay=Integer.parseInt(parameters[23][idx]);

print(temperatureFile);

Thread.sleep(10000000);



int imageNumber=0; //images taken so far
boolean samplePumpIsOn; //Used later to keep track of whether or not the pump is on
boolean lightIsOn=false;
boolean mediaPumpIsOn=false;
int ROIs;
double curIntensity;
long imageTime;
String title;
FileWriter fileW;
PrintWriter output;
xyStage = mmc.getXYStageDevice();
zStage = mmc.getFocusDevice();
PositionList pl = gui.getPositionList();
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss-z");
String startTime;
//**************************************************************************************************************************
//****************METHODS USED IN MAIN EXPERIMENT BELOW*********************************************************************
//**************************************************************************************************************************


long startTimeMillis=System.currentTimeMillis(); //Used to mark when the experiment started in Milliseconds
long lastBG;
gui.clearMessageWindow();
gui.closeAllAcquisitions();
gui.enableLiveMode(liveMode);
preparePositions();
mmc.setConfig(configGroup,darkPreset);


startTime=sdf.format(new Date());
if(retroAnalysis){
	// Set first to the first image that should be reanalyzed and last to the last image that should be reanalyzed.
	reAnalyzeImages(int first=1,int last=5, String dataFile="retroSummary")
}
loadTimeCourse();
prepareDataFile();
print("Images and results will be save in the "+saveDir+ "directory.");
//**************************************************************************************************************************
//****************MAIN EXPERIMENT BELOW*************************************************************************************
//**************************************************************************************************************************
while(System.currentTimeMillis()<(startTimeMillis+durationMillis){
		imageNumber++;
		ROIs=0;
		//amount of time media pump is on for every 30 seconds (0-1), sampling pump power (0-255), pinch valve (0-255), room light(255-> relay switch open and lights are off. 0-> relay switch closed and lights On)
		sendImmediateMessage(mediaRatioOn,0,0,255);
		Thread.sleep(settlingTime);
		//*******Prepare to take the images***************//
		gui.message("Image number: " + imageNumber);
		gui.enableLiveMode(false); //Stop the live video
		curIntensity=-100; //Measured intensity will not be negative. Initialized as negative to facilitate troubleshooting
		//This is an important method. It acquires the images, processes them, analyzes them, and saves the data
		acquireImages();
		sendImmediateMessage(mediaRatioOn,sampleRatioOn,255,255);
		lastBG=System.currentTimeMillis();
		generateBG();
		curIntensity=getData();
		print("The median intensity of the median pixel in the ROIs is "+curIntensity);
		if (liveMode) //Show video if liveMode (boolean)
			gui.enableLiveMode(true);
}//End of WHILE loop

FileWriter writer = new FileWriter(saveDir+dataFile+startTime+".csv",true); 
writer.write(lineSeparator+"Experiment ended at "+sdf.format(new Date()));
writer.close();

gui.enableLiveMode(false); //Stop the live video
print("Experiment completed. Last image taken at "+sdf.format(new Date()));


